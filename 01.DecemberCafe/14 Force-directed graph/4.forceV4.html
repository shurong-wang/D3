<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>力导向图 V4</title>
    <style>
        #canvas {
            width: 600px;
            height: 600px;
        }

        svg {
            border: 2px dashed #666;
        }

        text {
            font: 12px Microsoft YaHei;
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
            pointer-events: none;
            user-select: none;
        }

        .node {
            stroke-width: 1.5px;
        }

        .node-active {
            stroke-width: 2px;
        }

        .link {
            stroke-opacity: 1;
            stroke-width: 1;
        }

        .link-active {
            stroke-opacity: 1;
            stroke-width: 2;
        }

        .linetext {
            font-size: 12px Microsoft YaHei;
        }
    </style>
</head>

<body>
    <div id='canvas'></div>

    <script src='http://d3js.org/d3.v3.min.js' charset='utf-8'></script>
    <script>
        const width = 600;
        const height = 600;
        const styleMap = {
            node: {
                fillColor: {
                    Human: '#F05733',
                    Company: '#2B95CC'
                },
                strokeColor: {
                    Human: '#BF2B12',
                    Company: '#0E6DA2'
                },
                radius: {
                    Human: 26,
                    Company: 36
                }
            },
            line: {
                strokeColor: {
                    SERVE: '#9ACEDE',
                    OWN: '#D5E6AF',
                    INVEST_C: '#EE7456'
                }
            }
        };
        const api = 'data/v4.json';
        let nodesMap = {};
        let linkMap = {};

        // 力导向图
        const force = d3.layout.force()
            .size([width, height]) // 画布的大小
            .linkDistance(200) // 连线长度
            .charge(-2000); // 排斥/吸引，值越小越排斥

        // 全图缩放器
        const zoom = d3.behavior.zoom()
            .scaleExtent([0.25, 2])
            .on('zoom', zoomFn);

        // 节点拖拽器（使用 d3.behavior.drag 节点拖动失效）
        const drag = force.drag()
            .origin(d => d)
            .on('dragstart', dragstartFn)
            .on('drag', dragFn);

        // SVG
        const svg = d3.select('#canvas').append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .call(zoom)
            .on('dblclick.zoom', null);

        // 缩放层（位置必须在 container 之前）
        const zoomOverlay = svg.append('rect')
            .attr('width', width)
            .attr('height', height)
            .style('fill', 'none')
            .style('pointer-events', 'all');

        const container = svg.append('g')
            .attr('class', 'container');

        // 请求数据，绘制图表
        d3.json(api, (error, resp) => {
            if (error) {
                return console.error(error);
            }

            initialize(resp);
        });

        // 初始化
        function initialize(resp) {
            let {
                nodes,
                relations
            } = resp;

            // 生成 nodes map
            nodesMap = genNodesMap(nodes);

            // 构建 nodes（不能直接使用 api 中的 nodes）
            nodes = d3.values(nodesMap);

            // 起点和终点相同的关系映射
            linkMap = genLinkMap(relations);

            // 构建 links（source 属性必须从 0 开始）
            const links = genLinks(relations);

            // 绑定力导向图数据
            force
                .nodes(nodes) // 设定节点数组
                .links(links); // 设定连线数组

            // 开启力导向布局
            force.start();

            // 手动快速布局
            for (let i = 0, n = 1000; i < n; ++i) {
                force.tick();
            }

            // 停止力布局
            force.stop();

            // 固定所有节点
            nodes.forEach(d => {
                d.fixed = true;
            });

            // 箭头
            const marker = container.append('svg:defs').selectAll('marker')
                .data(force.links())
                .enter().append('svg:marker')
                .attr('id', d => d.type + '-arrow')
                .attr('markerUnits', 'userSpaceOnUse')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 39)
                .attr('refY', 0)
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('orient', 'auto')
                .attr('stroke-width', 2)
                .append('svg:path')
                .attr('d', 'M2,0 L0,-3 L9,0 L0,3 M2,0 L0,-3')
                .attr('fill', d => styleMap.line.strokeColor[d.type]);

            // 节点连线    
            const linkLine = container.selectAll('.link')
                .data(force.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr({
                    // 标记箭头
                    'marker-end': d => 'url(#' + d.type + '-arrow)',
                    'd': d => genLinkPath(d),
                    'id': (d, i) => 'link' + i,
                })
                // 根据关系的不同设置线条颜色
                .style('stroke', d => styleMap.line.strokeColor[d.type]);

            // 连线的文字
            const lineText = container.append('g').selectAll('.linetext')
                .data(force.links())
                .enter()
                .append('text')
                .style('fill', '#000')
                .attr({
                    'class': 'linetext',
                    'id': (d, i) => 'link' + i,
                    'dx': d => 80,
                    'dy': 5
                });

            lineText.append('textPath')
                .attr('xlink:href', (d, i) => '#link' + i)
                .text(d => d.alllabel);

            // 节点（圆）
            const nodeCircle = container.append('g')
                .selectAll('.node')
                .data(force.nodes())
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .call(drag); // 节点可拖动

            nodeCircle.append('circle')
                .style('fill', function (node) {
                    // 节点背景颜色
                    return styleMap.node.fillColor[node.ntype];
                })
                .style('stroke', function (node) {
                    // 节点描边颜色
                    return styleMap.node.strokeColor[node.ntype];
                })
                .attr('r', function (node) {
                    // 设置节点半径
                    return styleMap.node.radius[node.ntype];
                })
                .on('mouseover', function (node) {
                    // 加重节点样式
                    d3.select(this).classed('node-active', true);
                    // 加重连线样式
                    linkLine.classed('link-active', function (line) {
                        return isLinking(node, line);
                    });
                    // 只显示相连连线文字
                    lineText.style('fill-opacity', function (line) {
                        return isLinking(node, line) ? 1.0 : 0.0;
                    });
                }).on('mouseout', function (node) {
                    // 恢复节点样式
                    d3.select(this).classed('node-active', false);
                    // 连线恢复样式
                    linkLine.classed('link-active', false);
                    // 显示所有连线文字
                    lineText.style('fill-opacity', function (line) {
                        return 1.0;
                    });
                });

            // 节点文字
            const nodeText = container.append('g').selectAll('text')
                .data(force.nodes())
                .enter()
                .append('text')
                .attr('class', 'nodetext')
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .attr('x', function (d) {
                    // console.log(d.name+'---'+ d.name.length);
                    let re_en = /[a-zA-Z]+/g;
                    // 如果是全英文，不换行
                    if (d.name.match(re_en)) {
                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 2)
                            .text(function () {
                                return d.name;
                            });
                    }
                    // 如果小于四个字符，不换行
                    else if (d.name.length <= 4) {
                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 2)
                            .text(function () {
                                return d.name;
                            });
                    } else {
                        let top = d.name.substring(0, 4);
                        let bot = d.name.substring(4, d.name.length);

                        d3.select(this).text(function () {
                            return '';
                        });

                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', -7)
                            .text(function () {
                                return top;
                            });

                        d3.select(this).append('tspan')
                            .attr('x', 0)
                            .attr('y', 10)
                            .text(function () {
                                return bot;
                            });
                    }
                });

            // 更新力导向图
            function tick() {
                // 节点位置
                nodeCircle.attr('transform', d => 'translate(' + d.x + ',' + d.y + ')');
                // 节点文字位置
                nodeText.attr('transform', d => 'translate(' + (d.x) + ',' + d.y + ')');
                // 连线位置
                linkLine.attr('d', d => genLinkPath(d));
                // 连线文字角度
                lineText.attr('transform', function (d, i) {
                    if (d.target.x < d.source.x) {
                        bbox = this.getBBox();
                        rx = bbox.x + bbox.width / 2;
                        ry = bbox.y + bbox.height / 2;
                        return 'rotate(180 ' + rx + ' ' + ry + ')';
                    } else {
                        return 'rotate(0)';
                    }
                });
            }

            // 更新力导向图
            // tick 必须调用（否则，节点会堆积在左上角）
            // 且位置在 nodeCircle, nodeText, linkLine, lineText 后
            tick();

            // 监听力学图运动事件，更新坐标
            force.on('tick', tick);

        }


        function genLinks(relations) {
            return relations.map(function ({
                startNode,
                endNode,
                label,
                type
            }) {
                const mapKey = startNode + '-' + endNode;
                let lcount = linkMap[startNode + '-' + endNode];
                let alllabel = linkMap[startNode + '-' + endNode + '-label'];
                return {
                    source: nodesMap[startNode],
                    target: nodesMap[endNode],
                    label,
                    type,
                    alllabel: linkMap[mapKey + '-label'],
                    lcount: linkMap[mapKey],
                }
            })
        }

        function genLinkMap(relations) {
            const hash = {};
            relations.map(function ({
                startNode,
                endNode,
                label
            }) {
                const key = startNode + '-' + endNode;
                if (hash[key]) {
                    hash[key] += 1;
                    hash[key + '-label'] += '；' + label;
                } else {
                    hash[key] = 1;
                    hash[key + '-label'] = label;
                }
            });
            return hash;
        }

        function genNodesMap(nodes) {
            const hash = {};
            nodes.map(function ({
                id,
                name,
                ntype
            }) {
                hash[id] = {
                    id,
                    name,
                    ntype
                };
            });
            return hash;
        }

        // 生成关系连线路径
        function genLinkPath(d) {
            const sx = Math.round(d.source.x);
            const sy = Math.round(d.source.y);
            const tx = Math.round(d.target.x);
            const ty = Math.round(d.target.y);

            return 'M' + sx + ',' + sy + ' L' + tx + ',' + ty;
        }

        function zoomFn() {
            const {
                translate,
                scale
            } = d3.event;
            container.attr('transform', 'translate(' + translate + ')scale(' + scale + ')');
        }

        function dragstartFn(d) {
            d3.event.sourceEvent.stopPropagation();
            force.start();
        }

        function dragFn(d) {
            d3.select(this)
                .attr('cx', d.x = d3.event.x)
                .attr('cy', d.y = d3.event.y);
        }

        function isLinking(node, line) {
            return line.source.id == node.id || line.target.id == node.id
        }
    </script>
</body>

</html>