<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>力导向图 V4</title>
    <style>
        #canvas {
            width: 600px;
            height: 600px;
        }

        svg {
            border: 2px dashed #666;
        }

        text {
            font: Microsoft YaHei;
            pointer-events: none;
            user-select: none;
        }

        .node {
            stroke-width: 1.5px;
        }

        .node-active {
            stroke-width: 2px;
        }

        .link {
            stroke-opacity: 1;
            stroke-width: 1;
        }

        .link-active {
            stroke-opacity: 1;
            stroke-width: 2;
        }

        .linetext {
            font-size: 12px Microsoft YaHei;
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
        }
    </style>
</head>

<body>
    <div id='canvas'></div>

    <script src='http://d3js.org/d3.v3.min.js' charset='utf-8'></script>
    <script>
        const width = 600;
        const height = 600;

        const styleMap = {
            node: {
                fillColor: {
                    Human: '#F05733',
                    Company: '#2B95CC'
                },
                strokeColor: {
                    Human: '#BF2B12',
                    Company: '#0E6DA2'
                },
                textFillColor: {
                    Human: '#ff0',
                    Company: '#fff'
                },
                radius: {
                    Human: 26,
                    Company: 36
                }
            },
            line: {
                strokeColor: {
                    SERVE: '#9ACEDE',
                    OWN: '#D5E6AF',
                    INVEST_C: '#EE7456'
                }
            }
        };
        const nodeTextFontSize = 12;
        const lineTextFontSize = 11;

        // const api = 'data/v4.json';
        const api = 'data/v4.simple.json';

        let nodesMap = {};
        let linkMap = {};

        const menuMap = {
				width: 500,
				height: 500,
				innerRadius: 36,
				outerRadius: 36 + 24,
				color: '#00B9C4',
				dataset: [25, 25, 25, 25],
				iconPath: 'menu-icon/',
				handle: [
					'info',
					'equity',
					'tree',
					'relation'
				],
				iconSize: {
					width: 15,
					height: 15
				}
			};


        // 力导向图
        const force = d3.layout.force()
            .size([width, height]) // 画布的大小
            .linkDistance(200) // 连线长度
            .charge(-2000); // 排斥/吸引，值越小越排斥

        // 全图缩放器
        const zoom = d3.behavior.zoom()
            .scaleExtent([0.25, 2])
            .on('zoom', zoomFn);

        // 节点拖拽器（使用 d3.behavior.drag 节点拖动失效）
        const drag = force.drag()
            .origin(d => d)
            .on('dragstart', dragstartFn)
            .on('drag', dragFn);

        // SVG
        const svg = d3.select('#canvas').append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .call(zoom)
            .on('dblclick.zoom', null);

        // 缩放层（位置必须在 container 之前）
        const zoomOverlay = svg.append('rect')
            .attr('width', width)
            .attr('height', height)
            .style('fill', 'none')
            .style('pointer-events', 'all');

        const container = svg.append('g')
            .attr('class', 'container');

        // 请求数据，绘制图表
        d3.json(api, (error, resp) => {
            if (error) {
                return console.error(error);
            }

            initialize(resp);
        });

        // 初始化
        function initialize(resp) {
            let {
                nodes,
                relations
            } = resp;

            const nodesLength = nodes.length;

            // 生成 nodes map
            nodesMap = genNodesMap(nodes);

            // 构建 nodes（不能直接使用 api 中的 nodes）
            nodes = d3.values(nodesMap);

            // 起点和终点相同的关系映射
            linkMap = genLinkMap(relations);

            // 构建 links（source 属性必须从 0 开始）
            const links = genLinks(relations);

            // 绑定力导向图数据
            force
                .nodes(nodes) // 设定节点数组
                .links(links); // 设定连线数组

            // 开启力导向布局
            force.start();

            // 手动快速布局
            for (let i = 0, n = 1000; i < n; ++i) {
                force.tick();
            }

            // 停止力布局
            force.stop();

            // 固定所有节点
            nodes.forEach(d => {
                d.fixed = true;
            });

            // 箭头
            const marker = container.append('svg:defs').selectAll('marker')
                .data(force.links())
                .enter().append('svg:marker')
                .attr('id', d => d.type + '-arrow')
                .attr('markerUnits', 'userSpaceOnUse')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 39)
                .attr('refY', 0)
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('orient', 'auto')
                .attr('stroke-width', 2)
                .append('svg:path')
                .attr('d', 'M2,0 L0,-3 L9,0 L0,3 M2,0 L0,-3')
                .attr('fill', d => styleMap.line.strokeColor[d.type]);

            // 节点连线    
            const linkLine = container.selectAll('.link')
                .data(force.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr({
                    // 标记箭头
                    'marker-end': d => 'url(#' + d.type + '-arrow)',
                    'd': d => genLinkPath(d),
                    'id': (d, i) => 'link' + i,
                })
                // 根据关系的不同设置线条颜色
                .style('stroke', d => styleMap.line.strokeColor[d.type]);

            // 连线的文字
            const lineText = container.append('g').selectAll('.linetext')
                .data(force.links())
                .enter()
                .append('text')
                .style('font-size', lineTextFontSize)
                .attr({
                    'class': 'linetext',
                    'id': (d, i) => 'link' + i,
                    'dx': d => getLineTextDx(d),
                    'dy': 5
                });

            lineText.append('textPath')
                // .style('letter-spacing', '0pt')
                // .attr('lengthAdjust', 'spacingAndGlyphs')
                // .attr('textLength', d => d.alllabel.length * 10)
                .attr('xlink:href', (d, i) => '#link' + i)
                .text(d => d.alllabel);

            // 节点（圆）
            const nodeCircle = container.append('g')
                .selectAll('.node')
                .data(force.nodes())
                .enter()
                .append('g')
                .style('cursor', 'pointer')
                .attr('class', 'node')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .each(d => d.isActive = true)
                .call(drag); // 节点可拖动

            nodeCircle.append('circle')
                // .style('fill-opacity', .3)
                .style('fill', node => styleMap.node.fillColor[node.ntype]) // 节点背景颜色
                .style('stroke', node => styleMap.node.strokeColor[node.ntype]) // 节点描边颜色
                .attr('r', node => styleMap.node.radius[node.ntype]) // 设置节点半径
                .on('mouseover', function (node) {
                    // 提升节点层级
                    // this.parentNode.appendChild(this);
                    nodeCircle.sort((a, b) => a.id === node.id ? 1 : -1);
                    // 加重节点样式
                    const fillColor = styleMap.node.fillColor[node.ntype];
                    const hoverColor = d3.rgb(fillColor).brighter(0.33);
                    d3.select(this).style('fill', hoverColor);
                    d3.select(this).classed('node-active', true);
                    // 加重连线样式
                    linkLine.classed('link-active', line => isLinking(node, line));
                    // 只显示相连连线文字
                    lineText.style('fill-opacity', line => isLinking(node, line) ? 1.0 : 0.0);
                    // 显示节点菜单
                    node.isActive = true;
                })
                .on('mouseout', function (node, i) {
                    // 恢复节点样式
                    d3.select(this).style('fill', styleMap.node.fillColor[node.ntype]);
                    d3.select(this).classed('node-active', false);
                    // 连线恢复样式
                    linkLine.classed('link-active', false);
                    // 显示所有连线文字
                    lineText.style('fill-opacity', '1.0');
                    // 隐藏节点菜单
                    node.isActive = false;
                });

            // 节点文字
            const nodeText = nodeCircle.append('text')
                .attr('class', 'nodetext')
                .style('font-size', nodeTextFontSize)
                .style('font-weight', 600)
                .style('fill', ({ ntype }) => styleMap.node.textFillColor[ntype])
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .attr('x', function ({ name }) {
                    return textBreaking(d3.select(this), name);
                });

            // 节点菜单
			const pie = d3.layout.pie();

			const arc = d3.svg.arc()
				.innerRadius(menuMap.innerRadius)
				.outerRadius(menuMap.outerRadius);

			const menuContainer = nodeCircle.filter(function ({ntype}) {
                return ntype === 'Company';
            })
                .append('g')
                .style('display', d => d.isActive ? 'block' : 'none');
	
			const wheelMenu = menuContainer
                .selectAll('.wheel-menu')
				.data(pie(menuMap.dataset))
				.enter()
				.append('g')
				.on('click', function (d, i) {
					console.log(menuMap.handle[i]);
				});

            wheelMenu.append('path')
				.attr('fill', menuMap.color)
				.attr('stroke', '#fff')
				.attr('stroke-width', 1)
				.attr('d', d => arc(d));

            wheelMenu.append('image')
				.attr('width', menuMap.iconSize.width)
				.attr('height', menuMap.iconSize.height)
				.attr('x', - (menuMap.iconSize.width / 2))
				.attr('y', - (menuMap.iconSize.width / 2))
				.attr('transform', d => 'translate(' + arc.centroid(d) + ')')
				.attr('xlink:href', (d, i) => menuMap.iconPath + menuMap.handle[i] + '.png');


            // 更新力导向图
            function tick() {
                // 节点位置
                nodeCircle.attr('transform', d => 'translate(' + d.x + ',' + d.y + ')');
                // 连线路径
                linkLine.attr('d', d => genLinkPath(d));
                // 连线文字位置
                lineText.attr('dx', d => getLineTextDx(d));
                // 连线文字角度 
                lineText.attr('transform', function (d) {
                    return getLineTextAngle(d, this.getBBox());
                });
            }

            // 更新力导向图
            // 注意1：必须调用一次 tick （否则，节点会堆积在左上角）
            // 注意2：调用位置必须在 nodeCircle, nodeText, linkLine, lineText 后
            tick();

            // 监听力学图运动事件，更新坐标
            force.on('tick', tick);

        }

        function genLinks(relations) {
            return relations.map(function ({
                startNode,
                endNode,
                label,
                type
            }) {
                const mapKey = startNode + '-' + endNode;
                let lcount = linkMap[startNode + '-' + endNode];
                let alllabel = linkMap[startNode + '-' + endNode + '-label'];
                return {
                    source: nodesMap[startNode],
                    target: nodesMap[endNode],
                    label,
                    type,
                    alllabel: linkMap[mapKey + '-label'],
                    lcount: linkMap[mapKey],
                }
            })
        }

        function genLinkMap(relations) {
            const hash = {};
            relations.map(function ({
                startNode,
                endNode,
                label
            }) {
                const key = startNode + '-' + endNode;
                if (hash[key]) {
                    hash[key] += 1;
                    hash[key + '-label'] += '、' + label;
                } else {
                    hash[key] = 1;
                    hash[key + '-label'] = label;
                }
            });
            return hash;
        }

        function genNodesMap(nodes) {
            const hash = {};
            nodes.map(function ({
                id,
                name,
                ntype
            }) {
                hash[id] = {
                    id,
                    name,
                    ntype
                };
            });
            return hash;
        }

        // 生成关系连线路径
        function genLinkPath(d) {
            const sx = Math.round(d.source.x);
            const sy = Math.round(d.source.y);
            const tx = Math.round(d.target.x);
            const ty = Math.round(d.target.y);

            return 'M' + sx + ',' + sy + ' L' + tx + ',' + ty;
        }

        function zoomFn() {
            const {
                translate,
                scale
            } = d3.event;
            container.attr('transform', 'translate(' + translate + ')scale(' + scale + ')');
        }

        function dragstartFn(d) {
            d3.event.sourceEvent.stopPropagation();
            force.start();
        }

        function dragFn(d) {
            d3.select(this)
                .attr('cx', d.x = d3.event.x)
                .attr('cy', d.y = d3.event.y);
        }

        function isLinking(node, line) {
            return line.source.id == node.id || line.target.id == node.id
        }

        function textBreaking(d3text, text) {
            const len = text.length;
            if (len <= 4) {
                d3text.append('tspan')
                    .attr('x', 0)
                    .attr('y', 2)
                    .text(text);
            } else {
                const topText = text.substring(0, 4);
                const midText = text.substring(4, 9);
                let botText = text.substring(9, len);
                let topY = -18;
                let midY = 4;
                let botY = 22;
                if (len <= 9) {
                    topY += 9;
                    midY += 9;
                } else {
                    botText = text.substring(9, 11) + '...';
                }

                d3text.text('');
                d3text.append('tspan')
                    .attr('x', 0)
                    .attr('y', topY)
                    .text(function () {
                        return topText;
                    });
                d3text.append('tspan')
                    .attr('x', 0)
                    .attr('y', midY)
                    .text(function () {
                        return midText;
                    });
                d3text.append('tspan')
                    .attr('x', 0)
                    .attr('y', botY)
                    .text(function () {
                        return botText;
                    });
            }
        }

        function getLineTextDx(d) {

            const sr = styleMap.node.radius[d.source.ntype];
            const sx = d.source.x;
            const sy = d.source.y;
            const tx = d.target.x;
            const ty = d.target.y;

            const distance = Math.sqrt(Math.pow(tx - sx, 2) + Math.pow(ty - sy, 2));

            const textLength = d.alllabel.length;
            const deviation = 8; // 调整误差
            const dx = (distance - sr - textLength * lineTextFontSize) / 2 + deviation;

            return dx;
        }

        function getLineTextAngle(d, bbox) {
            if (d.target.x < d.source.x) {
                const { x, y, width, height } = bbox;
                const rx = x + width / 2;
                const ry = y + height / 2;
                return 'rotate(180 ' + rx + ' ' + ry + ')';
            } else {
                return 'rotate(0)';
            }
        }

    </script>
</body>

</html>